# 计算机组成与结构

## 计算机硬件组成
* **计算机硬件基本组成:五个** 运算器 控制器 存储器 输入设备 输出设备
* 存储器分为 **内部存储器** **外部存储器**

* 输如设备和输出设备合并成为外部设备
* **主机** CPU+主存储器

## 中央处理单元CPU
* **组成**: 运算器 控制器 寄存器
* **功能**: 程序控制 操作控制 时间控制 数据处理
+ #### ==运算器组成==: 
   - **算数逻辑单元 ALU** 实现对数据的算数和逻辑运算
   - **累加寄存器 AC** 预算结果或操作数的存放区
   - **数据缓冲寄存器DR**暂时存放内存的指令或数据
   - **状态条件寄存器PSW** 保存指令运行结果的条件码

* **运算器的功能**: 执行所有算术运算,执行所有的逻辑运算并进行逻辑测试
+ #### ==控制器组成==: 
   - 指令寄存器IR 暂存CPU执行指令
   - 程序计数器PC 存放指令执行地址
   - 地址寄存器AR 保存当前CPU所访问的内存地址
   - 指令译码器ID 分析指令操作码

* 控制器功能 控制整个CPU的工作 包括程序控制 时序控制

## 数的表示
   - 纯小数 约定小数点的位置在机器数的最高数值位之前
   - 纯整数 小数点的位置在机器数的最低数值位之后
   - 真值 机器数对应的实际数值

## 数的编码方式
+ **原码**  一个数的正常二进制表示 (数值0的原码有两种形式)
+ **反码** (数值0的原码有两种形式)
  - 正数的反码是原码 
  - 负数的反码是在源码的基础上 除符号位外其他各位取反
+ **补码*** (数值0只有一种形式)
   - 正数的补码是原码
   - 负数的补码是在原码的基础上,除符号位外按位取反,末位加一
+ **移码** (**无论正数负数,都是将原码的补码的符号位取反得到移码** )
   - 用作浮点数运算的阶码
 
## 浮点数表示
**浮点数**
+ 表示方法为N=F*2^E (E为阶码,F为尾数)
   - 二级制如 101.011=0.101011*2^3
   - 阶码为带符号的纯整数,尾数为带符号纯小数
   - ==能表示的范围由阶码确定,所表示的精度由尾数确定==
  
 ##### 浮点数的运算
+ 对阶  使两个数的阶码相同,小阶向大阶看齐
+ 尾数计算
+ 结果规格化

## 校验码
##### 码距
从A码到B码转换所需要改变的位数 (码距越大越利于纠错和检错)

##### 奇偶校验码
在编码中增加1位校验位来使编码中的1的个数为奇数(奇校验)或偶数(偶校验),从而使码距变为2
> **奇校验,偶校验**
含有奇(偶)数个1,接收方会计算接收到的编码有多少个1
奇偶校验只能检1位错,并且无法纠错

### 循环冗余校验码CRC
+ CRC只能检错不能纠错(可以检多项错)
+ CRC是由两部分组成,左边是信息码(原始数据)右边是检验码,校验码尾数越长,校验能力越强
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-03-20%2017%2011%2002.png) 

##### 循环冗余码计算
计算方式:
1. 在原始多项式后面加上多项式位数减一个0
2. 进行除法运算(一直上一,不同取一)
3. 最终得到的余数就是校验码
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-03-20%2017%2019%2010.png) 

收到方将数据与多项式进行模二运算.如果余数为0,说明校验正确

### 海明码
+ 在数据位置之间的确定位置上插入k个校验位,通过扩大码距实现检错和纠错
+ ==数据位是n位,校验位是k位,则n和k必须满足 2^k-1>=n+k==
+ 海明码校验位计算

## 计算机体系结构分类
#### **Flynn分类法**
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-03-20%2017%2045%2041.png) 

## 计算机指令
+ 一条指令由操作码和操作数两部分组成
+ 计算机指令执行过程:
   - 取指令 分析指令 执行指令

## 指令寻址方式
#### 指令寻址方式
+ 顺序寻址方式 当执行一段程序时,是一条指令接着一条指令顺序执行
+ 跳跃寻址方式 下一条指令的地址码不是由程序计数器给出,而是由本条指令直接给出

#### 指令操作数的指令方式
+ 立即寻址方式 指令地址码字段指出的不是地址,而是操作数本身
+ 直接寻址方式 在指令地址字段中直接指出操作数在主存中的地址
+ 间接寻址方式 指令地址码字段中所指向的存储单元中存储的是操作数的地址 (访问两次主存)
+ 寄存器寻址方式 指令中地址码是寄存器的编号

#### 指令系统
##### CISC 复杂指令系统
兼容性强,指令繁多,长度可变,由微程序实现
##### RISC精简指令系统
指令少,使用频率接近,依靠硬件实现

![](https://gitee.com/adboex/blog_images/raw/master/img/2023-03-20%2018%2001%2045.png)

## 指令流水线
+ 将指令分成不同的段,每段由不同的部分去处理
+ ![](https://gitee.com/adboex/blog_images/raw/master/img/2023-03-20%2018%2007%2005.png) 
#### 流水线的相关计算(重要)
+ 流水线周期 指令分成不同的执行段,其中执行时间最诚的段为流水线的周期
+ 流水线执行时间: 1条指令总执行时间+(总执行条数-1)*流水线周期
+ 流水线吞吐率: 总执行条数/流水线执行时间
+ 流水线加速比: 不使用流水线执行的时间/使用流水线执行时间
+ 超标量流水线技术: 就是并行执行普通流水线

## 存储系统(重点)
+ 分层存储体系主要是为了解决存储容量成本和速度之间的矛盾问题
#### 高速缓存Cache
+ 用来存储存储当前最活跃的程序和数据,位于CPU和主存之间
+ 通过地址映射获取Cache存储器地址(==由硬件自动完成映射==)
   - 直接映射 将Cache和主存分块编号,只有块号相同才能命中(造成资源浪费)
   - 全相联映像 可以任意一块内存和Cache对应 (比较复杂,冲突最低)
   - 组组相连映像 先分块再分组 组间采用直接映像 组内采用全相联映像

## 主存编址
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-03-20%2019%2055%2029.png)

## 总线结构
+ 内部总线 芯片与处理器之间通信的总线
+ 系统总线 
   - 数据总线 并行数据传输位数
   - 地址总线 系统可管理的内存空间的大小
   - 控制总线 传输控制命令
+ 外部总线

## 系统可靠性分析
+ 平均无故障时间 MTTF=1/失效率
+ 平均故障修复时间MTTR=1/修复率
+ 平均故障间隔时间 MTBF=MTTF+MTTR
+ 系统可用性=MTTF/(MTTF+MTTR)*100%

## 网络安全概述

+ 保密性 确保信息不暴露给未授权的实体 (信息加密,物理保密)
+ 完整性 保证数据传输过程中是正确无误的
+ 可用性 保证合法用户能以合法的手段来访问数据
+ 可控性 控制授权范围内的信息流向和行为方式
+ 不可抵赖性 信息数据参与者不能否认自己发送的数据

### 保密性
+ 明文 实际传输的真实数据
+ 密文 经过加密之后的数据
+ 加密 明文转换为密文的过程
+ 解密将密文转化为明文的过程
+ 加密算法 
   - **代换** 转换成完全不同的其他数据
   - **置换** 打乱明文顺序,进行重新置换
+ 密钥 加密和解密过程中使用的密码等.是隐藏的

##### 加密技术
> **对称加密技术**
对数据加密和解密的密钥是相同的,属于不公开密钥加密算法.其缺点是加密安全性不好,密钥分发困难(因为密钥还需要发送给接收方) 但是加密速度快,适合大数据的加密
常见的密钥加密算法
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-03-21%2010%2013%2032.png)
需要记住算法的名称,每个算法有多少位密钥


> **非对称加密技术**
公开密钥加密技术,各个用户分别由一对密钥,公钥是公开的,密钥是保密的(只有自己知道,接收方都不知道),使用公钥机密只能对应的私钥能解密,使用私钥加密,只有对应的公钥能解密
甲要发送给乙数据时,使用乙方的公钥来加密,这样只有使用乙方的私钥才能解密
**缺点是加密速度慢**(密钥多,计算量大,不适合加密大数据)
常见非对称加密算法:
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-03-21%2010%2027%2035.png)

### 完整性-信息摘要
+ 信息摘要就是明文的信息特征,当数据改变了信息摘要也会发生改变
+ 接收方会根据接收到的数据重新生成一个信息摘要,若摘要和接受到的摘要相同,则信息正确(信息摘要是由哈希函数生成的)
+ 信息摘要的特点:
   - 不管数据多长都会长生固定长度的信息摘要
   - 任何不同的输入数据都会产生不同的信息摘要
   - 只能由数据生成信息摘要,不能由信息摘要还原数据
+ **算法**
   - MD5 产生128位输出
   - SHA 安全散列算法,产生160位输出

### 不可抵赖性-数字签名
+ 属于非对称加密体制
+ 主要功能: 
   - 接收者能够核实发送者对报文的签名(确认该报文确实是发送者所发送的)
   - 接收者所确信接收到的数据和发送者完全一样
   - 发送者事后不能抵赖对报文的签名
+ 发送方使用私钥进行数字签名,接收方使用发送方的公钥解密

### 数字证书
+ 对发送方的公钥进行验证
> **原理** 
每一个发送方 都要向CA申请数字证书
当发送方要发送数据时,接收方首先下载CA的公钥取验证数字证书的真伪

## 安全威胁分类
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-03-21%2009%2055%2055.png)

### PKI
+ 提供公钥加密和数字签名服务的系统或者平台,目的是为了管理密钥和证书

+ PKI主要包括四个部分:
   - X.509格式证书
   - CA操作协议
   - CA管理协议
   - CA政策制定

# 操作系统知识

## 操作系统概述
+ 操作系统特征
   - 并发性 共享性 虚拟性 不确定性
+ 操作系统功能
   - 进程管理
   - 存储管理
   - 文件管理
   - 设备管理
+ 操作系统分类
   - 批处理操作系统
   - 分时操作系统(轮流使用CPU工作片)
   - 实时操作系统(快速响应)
   - 网络操作系统
   - 分布式操作系统(物理分散的计算机互联系统)
   - 微机操作系统(Windows)
   - 嵌入式操作系统
+ 计算机启动流程 BIOS系统->主引导系统->操作系统

## 进程的组成和状态
+ 进程的组成:
   - 进程控制块PCB(唯一标致)
   - 程序(进程要做什么)
   - 数据(存放进程时所需数据)
+ 进程的状态
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-03-28%2009%2037%2030.png)

## 前趋图
+ 用来表示哪些任务可以并行执行,哪些任务之间有顺序关系
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-03-28%2009%2046%2043.png)
ABC可以并行执行,但是必须在ABC执行完成后,才能执行D

## 进程资源图
+ 用来表示进程和资源之间的分配和请求关系
+ **阻塞节点** 某进程所请求的资源已经全部分配,无法获取所需资源,该进程被阻塞.如图P2
+ **非阻塞节点** 某进程所请求的资源还有剩余,可以分配给该进程继续运行.如图P3 P1
+ 当一个进程资源图中所有进程都是阻塞节点时,陷入死锁状态

![](https://gitee.com/adboex/blog_images/raw/master/img/2023-03-28%2009%2049%2048.png)

## 同步和互斥
+ **互斥** 某资源(临界资源)在同一时间内只能由一个任务单独使用,使用时需要加锁,使用完后解锁才能被其他任务使用
+ **同步** 多个任务可以并发执行,只不过有速度的差异,在一定情况下停下等待,不存在资源是否单独或共享的问题

+ **临界资源** 各进程间需要以互斥方式对其进行访问的资源
+ **临界区** 指进程对临界资源实施操作的那段程序

+ **互斥信号量** 对临界资源采用互斥访问,使用互斥信号量后其他进程无法访问,初值为1
+ **同步信号量** 对共享资源的访问控制,处置一般是共享资源的数量

## 信号量操作
+ **P操作** 申请资源 S=S-1 若S>=0则执行P操作的进程继续执行;若S<0则进程进入阻塞状态,并将其插入阻塞队列
+ **V操作** 释放资源,S=S+1.若S>0则执行V操作的进程继续执行;若S<=0,则从阻塞状态唤醒一个进程,并将其插入就绪队列

## 死锁
+ 当一个进程再等待永远不可能发生的事件时,就会产生死锁,若系统中有多个进程处于死锁状态,就会造成系统死锁
+ **死锁的四个必要条件**
   - 资源互斥
   - 循环等待
   - 不可剥夺
   - 相互请求
+ **解决死锁的四个方法** 
   - 死锁预防 采用某种策略限制并发进程对于资源的请求
   - 死锁避免 一般采用银行家算法(提前计算出一条不会死锁的资源分配方案,才会分配资源)
   - 死锁检测 允许死锁产生,系统第十运行一个检测死锁的程序,若检测到系统中发生死锁,则设法加以解除
   - 死锁解除 死锁发生后的解除方法,如强制剥夺资源,插销进程 

## 线程
+ 传统的进程有两两个属性:
   - 可拥有资源的独立单位
   - 可独立调度和分配的基本单位
+ ==引入线程后,线程是独立调度的最小单位,进程是拥有资源的最小单位==线程可以共享进程的公共数据,全局代码,变量,代码,文件等资源,但不能共享线程都有的资源,如线程的栈指针等标识数据

## 页式存储管理
+ 将内存空间分成一个个大小相同的物理块(页帧号)
+ 地址计算:分成页号和页内地址两部分
+ **优点**:利用率高,碎片小(只有在最后一个页有),分配和管理简单
+ **缺点**:增加了系统开销,可能产生抖动的现象
 
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-03-29%2009%2038%2051.png)

## 页面置换算法
### 最优算法 OPT
理论上的算法,无法实现,是在进程执行完成后进行的最佳效率计算,用来让其他算法比较差距.选择未来最长时间内不被访问的页面置换

### 先进先出算法 FIFO
先调入内存的页面先被置换淘汰,会产生抖动现象,非配得页数越多,缺页率可能越多(效率越低)

### 最近最少使用 LRU
在最近的过去,进程执行的过程的过程中,过去最少使用的页面被置换淘汰,根据局部性原理,这种方式效率高

## 块表
+ 是一块小容练的相联存储器,由快速存储器组成,按内容访问,速度快,并且可以从硬件上保证按内容并行查找,一般用来存放当前访问最频繁的少数活动页面的页号.
+ 块表是将页表存于Cache中,满标表示将页表存储再内存上
+ 满标需要访问两次内存才能取出页,而块表是访问一次Cache和一次内存

## 段式存储管理
+ 将进程空间分为一个个段,每段也有段号和段内地址,与页是存储不同的是,每段物理大小不同,分段是根据逻辑整体分段的
+ **地址表示** (段号,段内偏移)段内偏移不能超过该段号对应的段长.真正的内存地址是:段号对应的基地址+段内偏移
+ **优点** 程序逻辑完整修改不互不影响
+ **缺点** 内存利用率低,内存碎片浪费大

## 段页式存储管理
+ 先分段,后分页
+ **优点** 空间浪费小,存储共享容易
+ **缺点** 由于管理软件的增加,复杂性和开销页增加,执行速度下降

## 文件管理
+ 系统中共有13个索引,0-9为直接索引,每一个索引节点存放的是内容,假设每个物理盘大小为4 kb共可存4kb*10=40kb
+ 10号索引节点为一级间接索引节点,大小为4kb,存放的并非直接数据,而是链接到直接物理盘块的地址,假设每一个地址占4b,则共有1024个地址,对应1024个物理盘,可存1024*4kb=4098kb数据
+ 二级索引节点类似,直接存放一级地址,一级地址再存放物理盘块地址,而后连接到存放数据的物理盘块,容量又扩大了一个数量级,为1024*1024\*4kb数据

![](https://gitee.com/adboex/blog_images/raw/master/img/2023-03-29%2010%2026%2006.png)

## 树形文件目录
+ 全文件名=绝对路径+文件名.绝对路径和相对路径是不加最后的文件名的,只是单纯的路径序列(路径最前要有)

## 空闲存储空间管理
+ 空闲区表法 将所有空闲空间整合成一张表,即空闲文件目录
+ 空闲链表法 将所有空闲空间链接成一个链表,根据需要分配
+ 成组链接法 既分组,每组内又链接成链表,是上述两种方法的综合
+ **位视图法** 对每个物理空间用一位表示,为1则使用,为0则空闲,形成一张位视图

## 设备管理
### 设备管理的方式
+ 按数据组织分类
   - 块设备
   - 字符设备
+ 资源分配角度分类
   - 独占设备
   - 共享设备
   - 虚拟设备
+ 数据传输速率分类
   - 低速设备
   - 中速设备
   - 高速设备

### IO软件层次结构
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-01%2020%2049%2027.png)


## 输入输出技术
+ 程序控制方式
+ 程序中断方式
+ DMA方式
+ 通道方式
+ IO处理机

## 虚设备SPOOLINg
在外甥上建立两个数据缓冲区,分别位输入井和输出井,只需要将打印命令发出,数据就会排队存储在缓冲区中

![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-01%2021%2003%2059.png)

## 磁盘结构
+ 磁盘有正反两个盘面,每个同心圆就是一个磁道,每个同心圆又被划分为多个扇区

+ 读取数据时,磁头首先要寻找到对应的磁道,然后等待磁盘进行周期旋转,旋转到指定的扇区才能读取到对应的数据,会产生寻道时间和等待时间
   - 就是磁头移动到磁道所需要的时间和等待读写的扇区转到磁头下方所用的时间
   - 寻道时间耗时最长
+ 寻道时间调度算法
   - 先来先服务FCFS
   - 扫描算法SCAN
   - 单项扫面调度算法CSCAN

## 微内核操作系统
+ 只将最核心的东西放入内核中,其他能独立地东西都放入用户进程中
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-01%2021%2022%2022.png)

## 嵌入式操作系统
+ 特点 微型化,代码质量高,可裁剪可配置
+ 内核服务:异常中断,计时器,IO管理
+ 常见的嵌入式RTOS(实时操作系统) VxWorks RT-Linux
+ 嵌入式操作系统初始化过程按照自底向上,从硬件到软件初始化次序:
   - 片级初始化->板级初始化->系统初始化
    - 芯片级是微处理器的初始化,板卡级时其他硬件设备初始化,系统级初始化就是软件及操作系统初始化
    
# 数据库技术
+ 由四个部分组成 
   - 数据库 统一管理,长期存储在计算机内的有组织的相关数据的集合
   - 硬件 构成计算机系统包括存储数据所需的外部设备
   - 软件 操作系统 **数据库管理系统**及应用数据
   - 人员 **数据库管理员DBA**
 
## 三级模式 两级映像
+ 内模式:管理如何存储物理的数据,对应具体物理存储文件
+ 模式:又称概念模式,就是我们通常使用的基本表,根据应用,需求将物理数据划分成一张张表
+ 外模式:对应数据库中的视图这个级别,将表进行一定的处理后再提供给用户使用
+ 外模式-模式映像 表和视图之间的映射,若表数据发生了修改,只需修改此映射,无需修改应用程序
+ 模式-内模式映像:  是表和数据的物理存储之间的映射,若修改了数据存储方式,只需要修改此映射而不需要修改应用程序
+ ![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-01%2022%2006%2036.png)

## 数据库设计 
+ 需求分析 分析数据存储的要求,产出 数据流图 数据字典 操作说明书
+ 概念结构设计 ER图
+ 逻辑结构设计 将ER图转换成关系模式,也即转换成实际表和表中的列属性
+ 物理设计 根据生成的表生成物理数据库
 ![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-01%2022%2022%2055.png)

## ER模型
+ 数据模型的三要素:
   - 数据结构 所研究的对象类型的集合
   - 数据操作 对数据库中各种对象的实体允许执行的操作集合
   - 数据的约束条件 一组完整性规则的集合
+ 实体联系模型
   - 使用椭圆表示属性(一般没有) 
   - 长方形表示实体 
   - 菱形表示联系  联系两端要标注峦溪类型
+ 联系类型 一对一 一对多 多对多

## 关系模型
关系模型也是数据库中常用的表,包括实体的属性,标识出尸体的主键和外键

### 模型转换
+ 每一个实体都对应一个关系模式,联系分为三种
   - 1:1 联系可以放到任意的两段实体中,作为一个属性
   - 1:N 联系可以单独作为一个关系模式,**也可以在N端中加入1端实体的主键(用这个)**
   - M:N 的联系中必须作为一个单独的关系模式,其中主键是M和N端的联合主键

## 关系代数运算
+ 并 结果是两张表中所有记录数合并,相同记录只显示一次
+ 交 结果是两张表中相同的记录
+ 差 S1-S2结果是S1表中有而S2表中没有的那些记录
+ 笛卡尔积 S1\*S2,产生的结果包括S1和S2的所有属性列,并且S1中每条记录一次和S2中组合成一条记录,最终属性列为S1+S2属性列,记录数为S1\*S2
+ 投影 实际是按条件选择某关系模式中的某列

+ 选择 实际是按条件选择某关系模式中的某条记录

自然连接
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-06%2022%2037%2023.png)

## 键与约束
#### 键
+ 超键 能够唯一标识此表的属性的组合
+ 候选键 超键中去掉冗余的属性,剩余的属性就是候选键
+ 主键 任选一个候选键,及可作为主键
+ 外键 其他表中的主键
+ 主属性 候选键内的属性为主属性,其他属性为非主属性

#### 约束
+ 实体完整性约束 主键约束,主键值不能为空,也不能重复
+ 参照完整性约束 外键约束,外键必须是其他表中已经存在的主键的值,或者为空
+ 用户自定义完整性约束 自定义表达式约束,如设置年龄属性的值必须在0到150之间

## 范式
+ 第一范式 所有属性都不易再分割为两个或多个分量
+ 第二范式 满足第一范式的基础上,且每个非主属性完全依赖主键(不存在部份依赖)
+ 第三范式 满足第二范式的条件下,没有非主属性传递依赖与候选键时(本质就是主键要直接决定所有的非主属性)
+ BC范式 每个依赖的绝定因素必包含表中的候选码

## 模式分解
范式之间的转化一般都是通过拆分属性,即模式分解
+ **保持函数依赖分解** 对于关系模式R,分解出来的多个关系模式,保持原来的依赖集不表,则保持函数依赖的分解.另外要注意消除冗余依赖(如传递函数依赖)
+ **无损分解** 分解后的关系模式能够还原出原关系模式,就是无损分解
 ![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-07%2022%2018%2008.png)
只适合两个关系模式的情况

## 事务管理
+ 事务有一系列操作组成,这些操作早么全做要么不做
+ 四大特性
   - 原子性 要么全做,要么不做
   - 一致性 事务发生后数据是一致的,不会存在A账户转出但是B账户没有收到的情况
   - 隔离性 任一事务的更新操作直到其成功提交整个过程对其他事务都是不可见的,不同事务之间时隔离的互不干涉
   - 持续性 事务操作的结果时持续性的

## 并发控制
##### 并发控制中存在下面三个问题
+ 丢失更新 事务1和事务2对数据A进行了修改,事务2覆盖了事务1,丢失了事务1对A更新
+ 不可重复读 事务2读数据A之后事务1对数据A进行了修改并写回,若此时事务2再读A会发现数据不对.一个事务重复读A两次会发现数据A有误
+ 读脏数据 事务1对数据A进行了修改后,事务2读数据A,然后事务1回滚,数据A恢复了原来的值,那么事务2对数据A做的事就是无效的,读到了脏数据

### 三级封锁协议

#### 锁
+ **X锁 排他锁** 如果对数据对象A上锁,则只允许该事务读取和修改A,其他事物都不能在对A进行任何操作,直到T释放A上的锁
+ **S锁 共享锁** 若事务T对数据对象A加上S锁,则只允许T读取A,但不能修改A,其他事务只能在对A加S锁(能读不能修改),直到T释放A上的锁

#### 封锁协议
+ **一级封锁协议** 事务在修改数据R之前必须对其加X锁,直到事务结束后才能释放,可以解决丢失更新的问题
+ **二级封锁协议** 在一级封锁协议的基础上,事务T在读取数据R钱必须先对其加S锁,读完之后可释放S锁,可解决丢失更新,读脏数据的问题
+ **三级封锁协议** 一级封锁协议加上事务T在读取数据R之前先对其加S锁,知道数据结束才释放,可以解决丢失更新,读脏数据,数据重复的问题

## 数据库故障
+ 事务内部故障
   - 本身逻辑 可预期
   - 运算溢出 不可预期
+ 系统故障 系统停止运行任何时间,如系统故障,停电
+ 介质故障 物理介质损坏,几率最小破坏性最大
+ 计算机病毒 

## 数据库备份
+ 静态存储 冷备份,在转存储期间不允许对数据库进行任何存取,修改操作
   - 优点 非常快速地备份方法,容易归档(直接物理复制操作)
   - 缺点 只能提供到某一时间点上的恢复,不能做其他工作,不能按表或按用用户恢复
+ 动态转储 热备份,在转储期间允许出数据库进行存取,修改操作,转储和用户事务可并发执行
   - 优点 可在表空间或者数据库文件级备份 数据库仍可使用,达到秒级恢复
   - 缺点 不能出错,后果很严重,如果热备份不成功,结果全部无效
+ 完全备份 备份所有数据
+ 差量备份 仅备份上一次完全备份之后变化的数据
+ 增量备份 备份上一次备份之后变化的数据
+ 日志文件 在事务处理过程中,DBMS把事务开始事务结束以及对数据库的插入删除和修改的每次操作写入日志文件.

## 分布式数据库
分布式数据库位于不同的物理位置,使用全局的DBMS将所有数据局部数据库联网管理

+ 分片模式 
   - 水平分片 将表中的记录分别存放在不同的地方
   - 垂直分片 将表中的垂直的列值分别存放在不同的地方
+ 分布透明性
   - 分片透明性 用户或应用程序不需要知道逻辑上访问的表具体是如何分块存储的
   - 位置透明性 应用程序不关心数据存储物理位置的改变
   - 逻辑透明性 用户或应用程序无需知道局部使用的是那种数据模型
   - 复制透明性 用户或应用程序不关心复制的数据从何而来
   
## 数据仓库
数据仓库的目的不是为了应用,而是面向主题的,用来做数据分析,集成不同的表,而是相对稳定的,一般不会做修改,同时会在特定的时间点做大量的插入,反应历史的变化

## 数据挖掘
数据仓库形成后一是用来做数据的查询,分析,生成表.另一个是使用数据挖掘工具对这些历史数据进行挖掘,查找数据间的关系,发现剩余价值

#### 数据挖掘的分析方法
+ 关联分析 关联分析主要用于发现不同事物之间的关联性,一个事件发生的同时,另一个时间也经常发生
+ 序列分析 序列分析主要用于发现一定时间间隔内接连发生的事件,这些事件构成一个序列,发现的序列有普遍的意义
+ 分类分析 分类分析通过信息具有类别的样本特点,得到决定样本属于各种类别的规则或方法,分类分析时首先为每个记录赋予一个标记(一组具有不同特征的类别),按标记分类记录,然后检查这些标记的记录,描述这些记录的特点
+ 聚类分析 聚类分析是根据物以类聚的原理,将本身没有类别的样本聚集成不同的组,并对每个这样的组进行描述的过程

## 商业智能
+ BI系统主要包括**数据预处理**,**建立数据仓库**,**数据分析**和**数据展现**四个主要阶段
+ **数据预处理** 包括 数据抽取 转换和加载三个过程
+ **建立数据仓** 库则是处理海量数据的基础
+ **数据分析** 体现系统智能的关键,一般采用联机分析处理和数据挖掘两大技术
+ **数据展现** 保障系统分析和结果的可视化

## 反规范化技术
规范化操作可以防止插入异常,更新,删除异常和数据冗余,通过模式分解将表拆分,来达到这个目的表拆分之后解决了异常却不利于查询.每次查询都会关联很多表,降低查询效率

+ 技术手段:增加派生冗余列,增加冗余列,重新组表,分割表
+ 主要就是增加冗余,提高查询效率

# 网络和多媒体

## 计算机网络的分类
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-11%2021%2007%2021.png)

## 网络的拓扑结构

+ 总线型 利用率低,干扰大,价格低
+ 星型 交换机形成的局域网,中央单元负荷大
+ 环型 流动方向固定,效率低扩充难
+ 树型 总线型的扩充,分级结构
+ 分布式 任意节点连接,管理成本高

![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-11%2021%2009%2030.png)


## OSI七层模型
+ 物理层 二进制数据传输,物理链路和物理特性相关
+ 数据链路层 将数据封装成帧进行传送,传送到**物理主机**上
+ 网络层 数据分层传输和路由选择,将数据传送至**互联网的网络主机**上
+ 传输层 ==**端到端的连接**==,传送数据至主机**端口**上
+ 会话层 管理主机之间的会话,提供会话管理服务(建立维护和结束会话)
+ 表示层 提供解释所交换信息含义的服务,包括数据之间的格式转换,压缩,加密等操作
+ 应用层 实现具体的应用功能

## 网络互联硬件
+ 物理层 中继器(扩大信号),集线器(多路中继器)
+ 数据链路层 网桥(分析帧地址) 交换机 (多口网桥,MAC地址表)
+ 网络层 路由器(连接多个逻辑上分开的网络,路由选择)
+ 应用层 网关(连接不同类型且协议差别较大的网络,协议转换)

#### 传输介质
+ 有线介质 双绞线(最大长度100M),同轴电缆,光纤
+ 无线介质 微波,红外线和激光,卫星通信

## 网络的协议
局域网协议
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-11%2021%2041%2024.png)

广域网协议
+ 点对点协议PPP 拨号上网
+ 数字用户线xDSL(ADSL上传网速和下载网速不对等,一般下载速度很快)
+ 数字专线DDN
+ 帧中继

## TCP/IP协议族
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-22%2012%2018%2018.png)

##### 特性
+ 逻辑编址(网卡-物理地址)
+ 路由选择(定义路由器如何选择网络路径)
+ 域名解析(域名解析为IP地址)
+ 错误检测和流量控制(可靠性,防止拥塞)

### TCP/IP分层模型
+ 应用层 具体应用功能
+ 传输层 提供应用程序间端到端的通信
+ 网络层 又称IP层,处理器间的通信,数据以分组为单位
+ 链路层 负责接收IP数据报,并把数据报通过选定的网络发送出去
+ 硬件层

##### 网络层
+ IP 最重要的核心的协议,无连接,不可靠
+ ICMP 因特网控制信息协议,用来检测网络通信是否顺畅
+ ARP和RARP 地址解析协议,ARP是将IP地址转换为物理地址,RARP是将物理地址转换为IP地址

##### 传输层协议
+ UDP协议 不可靠连接,因为数据传输只管发送,不用对方确认,因此可能会有丢包的现象.一般用于视频,音频数据传输
+ TCP协议 可靠连接 因为有验证机制
   - 停止等待协议 TCP保证可靠传输的协议,停止等待就是指发送完一个分组就停止发送,等待对方的确认,只有对方确认过,才发送下一个分组
   - 连续ARQ协议 TCP保证可靠传输的协议,它是指发送方维护者一个窗口,这个窗口中不止一个分组,有好几个分组,窗口的大小是由接收方返回的win值决定的,所以窗口的大小是动态变化的,只要在窗口中的分组都可以被发送,这就使得TCP一次不是只发送一个分组了,从而大大提高了信道的利用率,并且它采用累计确认的方式,队医按序到达的最后一个分组发送确认
   - 滑动窗口协议 TCP流量控制协议,可变的窗口时不断向前走的,该协议允许发送发在停止并等待确认钱发送多个数据分组,不必每法送一个分组就停下来等待确认,该协议可以加速数据的传输,还可以控制流量的问题

#### 应用层协议
+ FTP 可靠的文件传出协议
+ HTTP 超文本传输协议,使用SSL加密后的安全网页协议为HTTPS
+ SMTP和POP3 邮件传输协议,邮件报文采用ASCII格式表示
+ Telnet 远程连接协议
----
**上面的都是可靠的**
+ TFTP 不可靠的小文件传输协议
+ SNMP 简单网络管理协议,必须以管理员的身份登录才能完成配置
+ DHCP 动态分配IP地址协议,客户机/服务器模型


### DNS 域名解析协议
+ DNS服务器 维持域名和IP地址对应的表格,层次结构为:本地域名服务器,权威域名服务器,顶级域名服务器,根域名服务器
+ 输入网址后首先会查询本地DNS缓存,无果后再查询本地DNS服务器,又分为递归查询和迭代查询
   - 递归查询 主机提出一个查询请求,本地服务器会自动一层一层查询下去,知道找到满足查询请求的IP地址,再在返回给主机(问一次,就可以得到最终的结果)
   - 迭代查询 服务器收到一次查询请求,就回答一次,但是回答的不一定是最终的地址,也可能是其他层次服务器地址,然后等待用户端再去提交查询请求,即问一次答一次,而后再去问其他的服务器,知道问到结果
   - 两者选择的依据是域名服务器是否空闲
 
## 路由选择策略
##### 静态路由选择(不能根据网络流量和拓扑结构的变化来调整自身的路由表)
+ 固定路由选择 每个网络节点存储一张表格,表格中每一项记录对应某个目的节点的下一节点或链路,当一个分组到达某节点时,该节点只要根据分组上的地址信息,便可从固定的路由表中查出对应的目的节点以及所对应选择的下一节点
+ 洪范式路由选择 又叫扩散法,一个分组由源站发送到与其相邻的所有节点,最先到达的目的节点的一个或若干个分组肯定经过了最短的路径,其主要应用在诸如军事网络等强壮性要求很高的场合
+ 随机路由选择 一个分组只在与其相邻的节点中随机选择一条转发
---
##### 动态路由选择 节点的路由选择要依靠网络当前的状态信息来决定,这种策略能够较好的适应网络流量,拓扑结构的变化,有利于改善网络的性能,但由于算法复杂,会增加网络的负担
+ 分布式路由选择
   - 距离向量算法 个系欸但周期性的向所有相邻节点发送数据刷新报文
   - 链路状态算法 各节点独立计算最短通路,能够快速适应网络变化,交换的路由信息少,复杂难以实现
+ 集中式路由选择  由网络中心负责全网状态信息的收集,路由计算及最佳路由的实现.最简单的方法是将最新的路由由定期发送到网络中的各节点上去
+ 混合式动态路由选择 将分布路由选择和集中路由选择,以及其他路由选择方法混合使用
 
## IP地址
### 分类地址格式: 
IP地址分为四段,每段八位,共32位二进制数构成

![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-12%2020%2003%2055.png)
+ A类地址网络号占8位,主机号则为32-8=24位,能分配的主机个数位2^24-2个(**主机号全为0和全为1不能分配,是特殊地址**)
+ B类地址网络号为16位,C类地址网络号为24位,同样可推出主机号位数和主机数
+ 上图红色的位数位该位固定为该值,是每类IP地址的表示
+ D类 为组播地址
+ E类 保留地址

### 子网划分

+ 将主机号拿出几位作为子网号,就可以划分出多个子网:此时IP地址组成为 网络号+子网号+主机号
+ 网络号和子网号都为一主机号都为0,这样的地址为子网掩码
+ 子网号可以全为0全为1,主机号不能全为0或全为1,因此主机数需要-2.而子网不需要
+ 还可以聚合网络为超网,就是划分子网的逆过程,将网络号取出几位作为主机号,此时这个网络内的主机数量就变多了,成为一个更大的网络

### 无分类编址
+ 不按照ABC类规则,自动规定网络号,无非类编址格式为" IP地址/网络号,示例128.168.0.11/20表示的IP地址为128.168.0.11,其中网络号占20位,因此主机号占12位

特殊IP地址
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-12%2020%2022%2047.png)

## IPV6
+ 地址长度位128位
+ 使用一系列固定格式的扩展头部取代了IPV4中可变长度的选项字段


+ 双协议栈 主机同时运行IPV4和IPV6两套协议栈,同时支持两套协议
+ 隧道技术 这种机制用来再IPV4网络之上连接IPV6的站点,站点可以是一台主机也可以是多台主机
+ 翻译技术 利用转换网关来再IPV4和IPV6网络之间转换IP报头的地址,从而使纯IPV4和纯IPV6站点之间能够透明通信
+ 

#### 层次化网络模型
+ 接入层 功能单一,向本地网段提供用户接入
+ 汇聚层 功能多样,可以有多层,包括网络访问策略,数据包的处理,过滤,寻址等中心操作
+ 核心层 功能单一,只负责高速的数据交换

#### 网络地址翻译 NAT 
+ 公司内有很多电脑,在公司局域网内可以互联通信,但是要访问外部英特网时,只提供固定的少量IP地址能够访问英特网,将公司所有电脑这个大的地址集合映射到能够访问因特网的少量IP地址集合的过程就称为NAT
+ 很明显,使用了NAT后一个公司只有少量固定IP地址可以上网,大大减少了IP地址的使用量

#### 默认网关
+ 一台主机可以有多个网关.默认网关的意思是一台主机如果找不到可用的网关,就把数据包发送到默认的指定网关,有这个网关来处理数据包,现在主机使用的网关一般指的是默认网关
+ 默认网关的IP地址必须与本机IP地址在同一网段内,即同网络号

#### 冲突域和广播域
+ 一个路由器下可以划分多个广播域和多个冲突域
+ 一个交换机下整体是一个广播域,但是可以划分多个冲突域
+ 集线器整体作为一个广播域和冲突域

## 网络安全

+ 物理层主要使用物理手段,屏蔽,隔离物理设备
+ SSL协议 用于网银交易
   - 三方面的服务:用户和服务器的合法性验证,加密数据以隐藏被传输的数据,保护数据的完整性
   - 实现过程: 接通阶段--密码交换阶段--会谈密码阶段--检查阶段--客户认证阶段--结束阶段
+ ![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-16%2011%2039%2011.png)

## 防火墙
#### 网络级防火墙
+ 层次低,效率高 
+ 一般只是检验网络包外在属性(起始地址,状态)是否异常
+ 不与内网通信,对应用和用户是透明的
+ 如果遇到伪装的危险数据包就没办法过滤

#### 应用防火墙
+ 层次高,效率低
+ 会将网络包拆开,具体检查数据是否有问题
+ 包括双宿主主机,屏蔽主机网关,屏蔽子网的方法

## 病毒
+ 系统引导型病毒
+ 文件外壳型病毒
+ 目录型病毒
+ 蠕虫病毒 感染exe文件
+ 木马
+ 宏病毒 感染word excel文件中的宏变量
+ CIH病毒 世界上唯一破坏硬件的病毒
+ 红色代码 蠕虫病毒+木马

# 多媒体

## 多媒体分为五类
+ 感觉媒体 直接作用于人的感觉器官  视觉听觉触觉
+ 表示媒体 指传输媒体的中介媒体,用于数据交换的编码 文字 图形 动画
 + 存储媒体 表示媒体的物理介质 磁盘光盘内存
+ 传输媒体 传输表示媒体的物理介质 电缆,光纤,双绞线\

#### 声音
+ 声音转换为数字信号步骤 采样 量化 编码
+ 采样的频率一般为最高频率的两倍才能保证不失真
+ 数字调频合成 FM  得到电子模拟声 是真实乐器不具备的音色
+ 波表合成法 Wavetable 将真实乐器发出的所有声音记录下来

# 程序设计
## 程序设计语言的基本成分
+ 数据成分 程序设计语言的数据和数据类型
+ 运算成分 允许使用的运算符号和运算规则
+ 控制成分 允许使用的运算符号和运算规则
+ 传输成分 允许的传输方式 如赋值,数据输入输出

## 编译程序的基本原理
+ 词法分析 读入源程序,识别单词
+ 语法分析 将单词序列组合成各类语法短语,判断源程序在结构上是否正确
+ 语义分析 逻辑阶段,对上下文有关性质审查(类型匹配,除法除数不为零),分为静态语义错误和动态语义错误
+ 中间
+ 代码和目标代码生成  常见的中间代码有后缀式,三元式,四元式
   - 如何生成较短的目标代码
   - 如何充分利用计算机中的寄存器
   - 如何充分利用计算机指令系统的特点

### 文法定义
形式文法是有一个有序的四元组G=(V,T,S,P)
+ V 非终结符 理解为占位符
+ T 终结符 是语言的组成部分,是最终结果
+ S 起始符 是语言的开始符号
+ P 产生式 用终结符替代非终结符的规则

tips
+ 终结符最终结果,不能推导出其他元素
+ 非终结符 能够推导出其他元素
+ 产生式 非终结符推导出终结符的公式
+ 闭包
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-23%2012%2036%2021.png)

### 文法类型
+ 0型 短语文法
+ 1型 上下文有关文法(==语义==)
+ 2型 上下文无关文法(==语法==)
+ 3型 正规文法

### 正规式
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-04-23%2012%2057%2041.png)

### 有限自动机
本质就是有向图从起点到终点的遍历
+ 确定有限自动机 输入一个字符看是否能得出唯一的后继
+ 不确定有限自动机 有多个后继

## 语法分析方法
+ **自上而下语法分析** 从左到右
+ **递归下降思想** 利用递归调用模拟语法树自上而下的构造过程
+ **自下而上语法分析** 最右推导,从右到左
+ **移进-规约** 自下而上


# 法律法规与标准化

## 保护期限

![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-01%2010%2026%2009.png)
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-01%2010%2026%2055.png)

## 知识产权人

### 单位和个人的著作权归属情况
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-01%2010%2029%2026.png)

### 委托开发
+ 当合同中无规定的著作权的归属时,著作权默认归于单位,委托创作中,著作权默认归属于创作方个人

![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-01%2010%2035%2013.png)

## 侵权判定
+ 中国公民,法人或者其他组织的作品,不论是否发表,都享有著作权
+ 开发软件所用的思想,处理过程,操作方法或者数学概念不受保护
+ 法律法规,时事新闻,通用公式不受著作权法保护

![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-01%2010%2041%2042.png)

## 其他法律细则
### 商业秘密
+ 构成条件  未公开,能为权利人带来利益,保密性
+ 商业秘密无固定的时间,一般由企业自行规定,且不能延长

### 专利权
+ 期限 发明专利权保护期限为自申请起20年,实用性专利权和外观设计专利权保护期限是自申请日起10年
+ 专利权谁先申请就先归谁,若同一天申请,则双方协商或者以抽签的方式决定

### 商标权
+ 必须使用注册商标的商品范围包括 国家规定并由国家工商行政管理局公布的人用药品和烟草制品,国家规定并由国家工商行政管理局公布的其他商品
+ 商标权认定方式与专利权类似,也是谁先申请就归谁,如果同一天申请,则谁先使用该商标就归谁,若都未使用或者同时使用,则由双方协商或者以抽签的方式决定
+ 近似商标是指文字,图形,在发音视觉含义或编排顺序整体结果上虽有一定的区别,容易产生混淆的商标,会产生商标侵权

### 引用资料
 + 只能引用发表的作品,不能引用未发表的作品,只能限于介绍,评论作品,不必证的原作者的同意,不需要向他支付报酬 
 
## 标准的分类
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-01%2011%2017%2050.png)  
# 数据结构

## 线性结构
+ 每个元素最多只有一个出度一个入度
+ 线性表分为顺序存储和链表 

### 线性表
+ 顺序存储和链式存储对比
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-01%2011%2034%2016.png)

### 循环队列
+ 头指针指向第一个元素,尾指针指向最后一个元素的下一个位置
+ 一般让队列少存一个元素,当队列满时为tail+1=head 队列为空时head=tail

### 广义表
+ 广义表是线性表的推广,是由0个或多个单元素或子表组成的有限序列
+ 广义表和线性表的区别 线性表的元素都是结构上不可分的单元素,而广义表的元素既可以单元素,也可以是有结构的表

### 二叉树
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-05%2021%2050%2029.png)

## 分治法
+ **定义** 对于一个规模为n的问题,若该问题可以容易的解决则直接解决,否则将其分解为k个规模较小的子问题,这些子问题相互独立且与原问题形式相同,递归的解决这些子问题,然后将各子问题的解和并得到原问题的解
+ **步骤** 
   - 分解 将原问题分解成一系列子问题
   - 求解 递归的求解各子问题,若子问题足够小,则直接求解
   - 合并 将子问题的解合并成原问题的解
 + 凡是涉及到分组解决的都是分治法(二分查找,归并排序)

## 回溯法
+ 可以系统的搜索一个问题的所有解和任意解,在包含问题的所有解的解空间树中,按照深度搜索优先的策略,从根节点出发搜索解空间树.搜索任意节点时,总是先判断该节点是否肯定不包含问题的解,如果不包含,则跳过以该节点为根的子树的搜索,逐层向其祖先节点回溯,否则继续搜索

+ 一般用于解决迷宫问题

## 动态规划法
+ 对于每一步决策列出各种可能的局部解,在依据某种判定条件,舍弃不能得到最优解的局部解,在每一步都经过筛选,以每一步都是最优解来保证全局是最优解
+ 本质是将复杂的问题划分成一个个子问题,与分治法不同的是每个子问题间不是相互独立的,并且不全部相同
+ 常用于求解具有某种最优性质的问题
+ 会花费大量的精力放在前期构造表格上面,列出可能的答案通过查询这张表来得到结果

+ 动态规划法不但每一步是最优的,全局也是最优的

## 贪心法
+ 总是做出当前来说最好的选择,而不是从整体上加以考虑,所做的每步选择只是当前步骤局部最优解,因此耗费的时间少,但得不到最优解

+ 判断是否是此类算法,就看算法每一步都取最优,但没有说结果是最优

## 分支限界法
+ **搜索原理** 
+ 每一个活结点==只有一次机会==称为扩展结点,活结点一旦成为扩展结点,就一次性产生其所有儿子节点,在这些儿子节点中,不可能解会被舍弃,其他二七进入活结点表中,从活结点表中取下一节点成为当前节点的扩展结点,直到活结点表为空为止

+ **与回溯法的区别** 
   - 求解目标是找出满足约束条件的一个解,或是在满足约束条件的解中找出使某个目标函数值达到极大或者极小的解,在某种意义下的最优解.
   - 以广度优先或以最小耗费(最大收益)优先的方式搜索解空间树
+ 选择下一个扩展结点的类型
   - 队列是分支限界法,按照队列先进先出的原则选取下一个节点为扩展结点
   - 按照队列规定的优先级选取优先级高的节点成为当前节点的扩展结点
 
## 概率算法
+ 在算法执行某些步骤时,可以随机的选择下一步该如何执行,同时允许结果以较小的概率出现错误,并以此为代价,获得算法运行时间的大幅度减少(降低算法复杂度)
+ **基本特征** 对所求解的问题同一实例用统一概率算法求解两次,可能得到完全不同的效果
+ 如果没有有效的确定性算法可以在合理的时间里给出解,但是能够接受小概率的错误,就可以使用概率算法求解

+ 四类概率算法
   - 数值概率算法 数值问题求解
    - 蒙特卡洛算法 求解问题的精确解
    - 拉斯维加斯算法 不会得到不正确的解
    - 舍伍德算法 总能得到问题的一个正确解

## 近似算法 
+ 解决难解问题的一种有效的策略,其根本思想时放弃求解最优,而用近似最优解代替最优解,以换取算法设计上的简化和时间复杂度的降低.

+ 为了具有实用性,近似算法必须能够给出算法所产生的解与最优解的差别或者比例的一个界限,这个差别越小,近似算法越具有实用性

## 数据挖掘算法
+ 分析爆炸式增长的各类数据的技术,其核心是算法,主要功能包括**分类,回归,关联规则,聚类**






























# 软件工程基础知识

## 软件工程基本要素: 
方法,工具,过程

 ## 软件生存周期:
1. 需求分析
2. 概要设计
3. 详细设计
4. 编码
5. 测试 
6. 维护

## 软件过程
> CMM 能力成熟度模型
>1. 初始级
>2. 可重复级 `可重复`
>3. 已定义级 `文档化,标准化`
>4. 已管理级 `指定详细度量标准`
> 5. 优化级
---
> CMMI
将已有的几个CMM结合在一起的集成模型
>1. 初始级
>2. 已管理级
>3. 已定义级
>4. 定量管理级
>5. 优化级

**CMMI 有1.阶段模式 2.连续模式 比CMM多了连续模式**

---

## 统一过程UP

### 特点
1. 用例和风险驱动
2. 以架构为中心
3. 迭代并且增量

### 开发四个阶段
1. 起始 `风险评估`
2. 精化 `需求分析 架构设计`
3. 构建  `编码`
4. 移交 `维护 测试`

每一次迭代都是一次完整的软件开发过程有五个核心工作流 `需求 分析 设计 实现 测试 `

 # 软件过程模型
 `主要考模型的特点`
 
 软件开发模型,软件开发的全部过程,活动和任务的结构框架
 
 ## 瀑布模型
 结构化开发,一步步走下去
 
 **只适用于需求明确的情况**

## V模型
瀑布模型的一个变体

增加了很多测试,不像其他模型是开发完成再测试

## 原型
与瀑布模型相反

面向`需求不明确`的情况

不断的演示与用户沟通

**采用的是迭代的思想**

## 螺旋模型
也是针对需求不明确的项目

增加了`风险分析`

**出现了需求不明确就是原型,出现了风险分析就是螺旋模型**

## 增量模型

先开发核心模块功能再开发次核心功能

**增量模型的每次增量版本都可以作为独立的可操作的作品**

## 喷泉模型

面向对象的开发方法
`迭代性 无间隙性`

## 基于构建的开发模型
用预先包装的构建来构造应用系统
增强了复用性,节省了时间和成本
## 形式化方法模型
建立在数学基础上

# 软件开发方法

## 结构化方法

针对`需求明确`,自顶向下逐层分解`面相数据流`
以瀑布模型为代表

> 结构化方法的设计
>1. 体系结构设计
>2. 数据设计 (数据流的设计)
>3. 接口设计(关注模块间的链接)
>4. 过程设计(算法的设计)

## Jackson方法
面向`数据结构`的开发方法

## 原型方法
适用于`需求不明确`的开发(以原型模型为代表)

## 面型对象方法
强调复用性 以构建组装模型为代表

## 敏捷开发

针对中小型项目
减少不必要的会议和文档 

> 结对编程
一个人开发一个人审查代码

> 自适应开发
强调适应性

> 水晶方法
不同项目有一套不同的策略

> 极限编程XP
文档少
沟通 简明 反馈 勇气
测试先行

> 并列争球法
30天冲刺开发
迭代

## 软件工具
+ 软件开发工具
    - 需求分析工具
    - 设计工具
    - 编码与排错工具
    - 测试工具
+ 软件维护工具
    - 版本控制工具
    - 文档分析工具
    - 开发信息库工具
    - 逆向工程工具
    - 再工程工具
+ 软件管理和软件支持工具
    - 项目管理工具
    - 配置管理工具
    - 软件评价工具

## 软件开发环境

由软件工具集和环境集成机制构成

##### 环境机制:
1. 环境信息库
2. 过程化界面规范
3. 用户界面规范

# 软件项目管理(不常考)
管理集中在4P上 人员 产品 过程 项目

> 软件项目估算方法
自顶向下
自底向上`新项目一般用`
差别估算`找不同点重新估算`
专家估算`请专家估算`

## COCOMO模型
常用代码行分析法作为其中一种度量方法

> 基本COCOMO模型
静态单变量

> 中级COCOMO模型
多因素考量

> 详细COCOMO模型
包括中间CONOMO模型的所有特征,多考虑工程中的每一个步骤

> COCOMO II 模型
包括三个阶段模型
1.应用组装模型 2.早期设计阶段模型 3.体系结构阶段模型

> Putnam估算模型
动态多变量

## 进度管理
### Gant图
能反映活动间的并行关系
无法反映活动之间的依赖关系
难以确定关键人物和关键路径

### PERT图
类似于前驱图
反应活动之间的依赖关系
无法反应活动之间的并行关系

> 关键路径重要概念
最早开始时间ES
最找完成时间EF
关键路径`项目中耗时最长的一条线`
最晚完成LF `要先顺推在逆推`
最晚开始时间
松弛时间`最晚开始时间-最早开始时间`

## 软件项目的组织

> 组织结构模式
项目型 `形目经理绝对领导`
职能型 `部门领导为主`
矩阵型 `二者结合`

> 程序设计小组的组织方书
主程序员制小组 `主程序员负责蛇和大规模项目`
民主制小组`任何决议都是有全员投票,适合规模小的项目`
层次式小组`两个层次,一名组长领导若干个高级程序员`

## 软件质量管理
### 质量特性(会考)
1. 功能性 `适应性` `准确性` `互用性` `安全性` `依从性`
2. 可靠性`成熟型` `容错性` `易恢复性`
3. 易用性`易理解性` `易学性` `易操作性`
4. 效率`时间特性` `资源特性`
5. 可维护性(重要)`易分析性` `易改变性` `稳定性`
6. 可移植性`适应性` `易安装性` `一致性` `易替换性`

## McCAll质量模型

### 三个方面
> 产品修正
产品转移
产品运行

### 三层框架
> 质量特性
评价标准
度量指标

## 软件质量保证
### 三个要点
> 软件必须满足用户要求
应遵循规定的一系列开发标准
满足一些隐含要求

### 七个任务
> 应用技术方法
正式的技术评审
测试软件
标准的实施
控制变更
记录保存和报告

## 软件容错技术
### 两个必要条件
> 设计质量评审
程序质量评审

### 软件容错技术
实现容错的主要手段就是冗余
+ 结构冗余
+ 信息冗余 `为检错和纠错添加额外信息`
+ 时间冗余 `遇到错误重复执行`
+ 冗余附加技术 `为了实现冗余的时间和技术`

## 软件配置管理
+ 基线:项目生存周期各开发阶段末尾的特定点
+ 软件配置项:软件工程中产生的信息(文档,代码,工具)
+ 版本控制

## 风险管理
### 包括五个方面
+ 市场风险
+ 策略风险
+ 销售风险
+ 管理风险
+ 预算风险

### 风险管理过程
1. 风险识别
2. 风险预测
3. 风险评估
4. 风险控制

## 软件度量
软件的两种属性
+ 外部属性 `可以直接测量,一般为性能指标`
+ 内部属性 `产品本身的属性,如可靠性`

### McCabe(常考)环路复杂度
环路复杂度为m-n+2(边数减顶点数加二)
**只有入度没有出度的线是不算的**

---

# 系统分析
+ 分析系统到底做什么: 产生系统方案说明书
+ 系统开发的目的是将现有系统的物理模型转换为目标系统的物理模型
+ 系统设计基本原理:`抽象` `模块化` `信息隐蔽` `模块独立`

> 内聚程度从低到高
偶然内聚 `无直接管理`
逻辑内聚 `逻辑相似,参数决定`
时间内聚 `同时执行`
过程内聚 `指定的过程顺序`
通信内聚 `相同数据结构,形同输入输出`
顺序内聚 `顺序执行`
功能内聚 `共同作用,缺一不可`

> 耦合从低到高
无直接耦合 `无直接关系`
数据耦合 `传递数据值调用`
标记耦合 `传递数据结构`
控制耦合 `控制变量,选择执行某一功能`
外部耦合 `软件外部环境`
公共耦合 `公共数据结构`
内容耦合 `模块内部关联`

# 系统设计

## 概要设计
设计软件系统总体结构
编写概要设计文档

## 详细设计的基本任务
模块内详细算法设计
编写详细设计说明书

## WebApp分析与设计
采用敏捷开发过程模型
网络密集性 并发性 无法预知负载量 
构建设计包括 内容设计元素 功能设计元素

### MVC 模型-视图-控制器
WebApp基础结构模型之一 将功能和信息分离

# 软件需求
+ 按内容分类  
    - 业务需求 `又客户提出`
    - 用户需求 
    - 系统需求
+ 按用户角度分类
    - 基本需求
    - 期望需求
    - 兴奋需求
+ 软件需求分类
    - 功能需求
    - 性能需求
    - 设计约束

## 需求工程
1. 需求获取
2. 需求分析与协商
3. 系统建模
4. 需求规约 `完成需求规格说明书`
5. 需求验证 `需要用户签字`
6. 需求管理

## 需求管理
1. 点工艺需求基线
2. 处理需求变更
3. 需求跟踪

# 结构化分析(重点)
需要建立 功能模型(数据流图) 行为模型(状态转换图) 数据模型(ER图) 数据字典

## 数据流图
描述数据在系统中如被传送或变换
数据流图可以分层 `顶层描述上下文无关的数据流`

> 对于同一个加工输入与输出名字必须不相同
对于每一个加工必须有输入数据流又有输出数据流
外部实体与外部实体之间不存在数据流
外部是实体与数据存储之间不存在数据流
数据与数据存储之间不存在数据流
数据流中必须有加工

## 测试

### 测试阶段
+ 单元测试 `对单个模块测试` `依据测试软件详细说明书`
    - 驱动模块 (上层)
    - 桩模块(底层)

+ 集成测试 `将模块组合起开进行测试`
    - 一次性组装 `只适合小项目` `节约时间发现错误少`
    - 增量组装 `能够发现更多错误耗时长`

+ 确认测试 
    - Alpha测试 `在开发环境下测试`
    - Beta测试 `在实际使用时测试`
    - 验收测试 `根据SRS对项目进行验收`

+ 系统测试 `对软件性能进行测试` `采用黑盒测试`
    - 负载测试 `在极限情况下`
    - 强度测试 `系统资源量特别低的情况下`
    - 容量测试 `并发测试 -测试可以同时处理在线的最大用户量`

+ 回归测试
    - 验证之前正确的代码是否引入了新错误
 
### 测试方法

+ 动态测试 `程序运行时测试`
    - 黑盒测试 `不了解代码结构` `根据功能设计用例 测试软件功能`
    - 白盒测试 `明确代码流程` `根据代码逻辑设计用例进行覆盖`
    - 灰盒测试 `有黑盒也有白盒`

+ 静态测试 `程序静止时` `进行人工审查`
    - 桌前检查 `程序员检车自己编写的程序` `程序编译后单元测试前`
    - 代码审查 `由程序员组成评审小组,通过招考会议进行审查`
    - 代码走查 `由测试人员提供测试用例,让长序员扮演计算机的角色手动运行`

### 测试策略

+ 自底向上 `较早验证了底层模块` `需要编写驱动程序`
+ 自顶向下 `较早验证了系统的主要控制金额判断点` `需要编写桩程序`
+ 三明治 `工作量较大`

### 测试用例设计

+ 黑盒测试用例
    - 等价类划分 `对所有涉及进行分类,从每一个类中选取一个` `使其尽可能多的覆盖尚未被覆盖的测试用例` `使其覆盖一个尚未被覆盖的无效等价类`
    - 边界值划分 `将每类的边界值作为测试用例`
    - 错误推测 `凭经验推测`
    - 因果图 `由结果反推原因`

+ 白盒测试 `覆盖代码`
***覆盖级别由低到高***
    1. 语句覆盖 `所有语句执行一遍`
    2. 判定覆盖 `所有判断语句真假覆盖各一次` `只管大集体`
    3. 条件覆盖 `对判断语句的独立条件做覆盖` `只管小集体`
    4. 判定/条件覆盖 `包含前两两个`
    5. 条件组合覆盖 `判定条件各种可能值的组合至少出现一次`
    6. 路径覆盖 `逻辑代码中的所有可行路径全部覆盖`
    
## 调试
+ 蛮力法
+ 回溯法 `从出错大地方开始向回找`
+ 原因排除法 `找出可能的原因,逐一进行排除`
    - 演绎法
    - 归纳法
    - 二分法

## 系统转换

数据转换 转换过程称为ETL 分为
1.抽取 2.转换 3.装载

+ 直接转换 `风险大` `节省成本` `适用于信息同步发杂,或老系统不能使用`
+ 并行转换 `适用于大型系统` 
+ 分段转换 `更耗时` `需要协调接口等问题`


## 系统维护
+ ==系统可维护性== `修改软件的难易程度`
+ 易测试性 
+ 易分析性 `诊断缺陷或失效的原因`
+ 易改变性
+ 稳定性

系统维护包括 硬件维护 软件维护 数据维护
> 软件维护分为:
正确性维护
适应性维护 `被动对外部环境进行适应`
完善性维护 `主动对软件提出更多需求`
预防性维护

# 面向对象技术
## 面向对象基础

### 面向对象基本概念

+ 继承 父类和子类共享数据的方法和机制
+ 不同的对象收到同一个消息产生完全不同的反应
   - 参数多态 不同类型参数多种结构类型
   - 包含多态 父子类型关系
   - 过载多态 类似于重载,一个名字不同含义
   - 强制多态 强制类型转换
+ 子类置换父类方法的实现同名同参(函数重载同命不同参数)

### 面型对象分析设计
+ 认定对象
+ 组织对象 分析对象,抽象成类
+ 对象间的相互作用 描述对象在应用系统中的关系
+ 确定对象的操作
+ 定义对象的内部信息

边界类 :系统内部与系统外部的业务主角之间进行交互建模的类

边界类: 系统内部与系统外部的业务主角之间进行交互建模的类


## UML 统一建模语言

> 三要素 
UML基本构造块(后两个不考) 事物 关系
图

> UML四种事物
结构事物 `模型的静态部分`
行为事物 `模型的动态部分`
分组事物 `模型的组织部份` `包`
注释事物 `模型的解释部分`

> 关系
依赖 `一个事物的予以依赖于另一个事务的语义变化`
关联 `描述部分与整体的关系`
泛化 `一般和特殊的关系` `子类和父类的关系`
实现 `一个类实现了另一个类`
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-14%2022%2050%2027.png)



### 用例图
+ 静态图

+ 展现了一组用例,参与者,和它们之间的关系

+ 用例图中的参与者是人,硬件或其它系统可以扮演的角色 

+ 用例之间的关系:包含 扩展 泛化
+ 用例是参与者完成的一系列操作

> 包含关系 必须有的功能
扩展关系 可做可不做
泛化关系 父类和子类的关系


#### 有一个小人
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-20%2015%2020%2041.png)

### 序列图
+ 动态图
+ 同步消息用实心箭头表示
+ 异步消息用空心箭头表示

+ 以时间顺序组织的对象之间的交互活动

+ 有同步消息和异步消息(从左到右),返回消息(从右到左)

#### 三个时间轴
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-20%2015%2024%2042.png)

### 对象图 ==静态设计视图==
某一时刻一组对象及它们之间的关系,为类图某一时刻的快照

#### 有点类似变成属性和方法的设计
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-20%2015%2023%2030.png)


### 通信图
和顺序图统称为交互图

#### 发动动作函数
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-20%2015%2033%2043.png)

### 状态图
动态图

+ 描述了单个对象在多个用例中的行为
+ 实心圆为起点和终点
+ 可以没有终点,但不能没有起点

#### 状态之间的转换 有中括号

![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-20%2015%2032%2040.png)
### 活动图
展现了系统中从一个活动到另一个活动的过程

+ 活动图的分叉和汇合是一条水平粗线

#### 有水平的粗线,开始结束的两个黑点
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-20%2015%2025%2046.png)


### 构件图
系统的静态实现图

#### 像骨关节一样的东西
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-20%2015%2027%2002.png)

### 部署图
物理模块的节点分布 
#### 几个小盒子
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-20%2015%2040%2034.png)

## 设计模式

+ 设计模式的四个基本要素
   - 模式名称,问题 应该在何时使用模式
   - 解决方案 设计的内容
   - 效果 模式应用的效果
+ 分为三类
   - 创建型模式 处理创建对象
   - 结构性模式 处理类和对象的组合
   - 行为型模式 描述类或者对象的交互行为

### 创建型设计模式
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-06%2018%2026%2046.png)

### 结构型设计模式
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-06%2018%2029%2054.png)
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-06%2018%2030%2024.png)


### 行为型设计模式

![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-06%2020%2016%2042.png)
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-06%2020%2017%2011.png)
![](https://gitee.com/adboex/blog_images/raw/master/img/2023-05-20%2015%2050%2032.png)

 
